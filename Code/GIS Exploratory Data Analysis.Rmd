---
title: "GIS Exploratory Data Analysis"
author: "Group P4T2"
date: "2024-02-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(ggplot2)
library(tidyverse)
library(sf)
library(dplyr)
library(tidyr)
```

# Data Data Cleaning for GIS Analysis

```{r read data}

# Read the PSE and Equity shape files
pse_data <- st_read("../Data/PSE_Gas_Tracts_2.shp")
equity_data <- st_read("../Data/Race_and_Social_Equity_Composite_Index_for_2020_Census_Tract_Geographies.shp")

```

pse_data aggregates gas consumption data by sector, year (2020-2023), and census tract in Seattle. Equity_data integrates race, ethnicity, socioeconomic status, and health disadvantages in Seattle.

Below we will create three data frames. 
The first data frame (GIS_EE_2023) will only include pse_data from 2023 and be merged with the equity data. 
The second data frame (GIS_Equity) will be include all of the equity_data. 
Finally, the third data frame (GIS_Energy), will only contain pse_data.

For equity_data we will merge on GEOID and pse_data will merge on Census_Tract. 

```{r column names}
# Get column names of pse_data and equity_data
colnames(pse_data)
colnames(equity_data)
```


```{r GIS 2023 - Merge Data}

# Step 1: Filter the PSE data for the year 2023
pse_data_2023 <- subset(pse_data, CAL_YEAR == 2023)

# Step 2: Ensure the GEOID and Census_Tract columns are of the same type before merging
pse_data_2023$Census_Tra <- as.character(pse_data_2023$Census_Tra)
equity_data$GEOID <- as.character(equity_data$GEOID)

# Step 3: Convert to regular dataframes for the merge operation, and drop geometry column from equity_data
pse_data_df <- as.data.frame(pse_data_2023)
equity_data_df <- as.data.frame(equity_data %>% st_set_geometry(NULL))

# Step 4: Merging the filtered 2023 PSE data with the equity data on GEOID/Census_Tract
merged_data_df <- inner_join(pse_data_df, equity_data_df, by = c("Census_Tra" = "GEOID"))

# View the merged dataframe
head(merged_data_df)

```


This code filters pse_data for entries from the year 2023 and ensures that the identifiers (Census_Tra from pse_data_2023 and GEOID from equity_data) are of compatible data types for merging. It then converts both datasets to regular dataframes, explicitly removing the geometry column from equity_data to simplify the merge operation. 

An inner_join is performed based on these identifiers, merging attributes from equity_data into pse_data_2023 where their identifiers match. Finally, after cleaning, the merged dataframe is converted back into an sf object by reattaching the geometry from pse_data_2023. 

This process ensures a streamlined dataset that combines relevant attributes from both sources, based on the year 2023 and matching geographic identifiers, for detailed spatial analysis.


```{r GIS 2023 - Clean Data}
#drop unnecessary columns from the equity data portion of the joined data set
merged_data_df = subset(merged_data_df, select = c(OBJECTID_1, ID, CAL_YEAR, Cal_Qtr,Census_Tra, Sector, Grouped_Fl,Usage_MMBT, Number_Acc, Emissions_, USAGEPERCA, EMISSIONSP, RSE_Quinti, SHAPE_Leng.x, SHAPE_Area.x, COMPOSITE_,RACE_ELL_O,SOCIOECON_,HEALTH_DIS,SOCIOECO_2,SHAPE_Leng.y,SHAPE_Area.y, RACE_ELL_1,HEALTH_D_1,COMPOSIT_1, COMPOSIT_2,RACE_ELL_2,SOCIOECO_1,HEALTH_D_2))

head(merged_data_df)

#renaming columns to names in the data table to make it less confusing
merged_data_df <- merged_data_df %>% rename(Grouped_Flag=Grouped_Fl, Usage_MMBTU=Usage_MMBT, Number_Accts=Number_Acc, Emissions_MTCO2E=Emissions_, USAGEPERCAPITA_MMBTU=USAGEPERCA, EMISSIONSPERCAPITA_MTCO2E=EMISSIONSP, RSE_Quintile=RSE_Quinti, SHAPE_Length.x=SHAPE_Leng.x, SHAPE_Length.y=SHAPE_Leng.y, COMPOSITE_PERCENTILE=COMPOSITE_, RACE_ELL_ORIGINS_QUINTILE=RACE_ELL_1, SOCIOECON_DISADV_QUINTILE=SOCIOECO_2, HEALTH_DISADV_QUINTILE=HEALTH_D_1, COMPOSITE_QUINTILE=COMPOSIT_1, COMPOSITE_SCORE=COMPOSIT_2, RACE_ELL_ORIGINS_SCORE=RACE_ELL_2, SOCIOECON_DISADV_SCORE= SOCIOECO_1, HEALTH_DISADV_SCORE=HEALTH_D_2, RACE_ELL_ORIGINS_PERCENTILE=RACE_ELL_O, SOCIOECON_DISADV_PERCENTILE=SOCIOECON_, HEALTH_DISADV_PERCENTILE=HEALTH_DIS)

head(merged_data_df)

sapply(merged_data_df, function(x) sum(is.na(x)))
#there are no missing values

#making the QUINTILE labels uniform across the columns (Highest priority value differs)
merged_data_df[merged_data_df == 'Highest Equity Priority' | merged_data_df == 'Highest Equity Priority/Most Disadvantaged' | merged_data_df == 'Highest priority/Most disadvantaged'] <- 'Highest'

#unique(merged_data_df$RACE_ELL_ORIGINS_QUINTILE)
#unique(merged_data_df$SOCIOECON_DISADV_QUINTILE)
#unique(merged_data_df$HEALTH_DISADV_QUINTILE)
#unique(merged_data_df$COMPOSITE_QUINTILE)
#unique(merged_data_df$RSE_Quintile)
```
This code selects a subset of relevant columns from the merged dataframe to reduce the number of parameters and only ones that we are likely to use remain. Then, it renames the columns because the abbreviations were unclear about what data is contained in the column. It checked for missing values in the columns but there were none. Finally, it changes the Highest Priority level label to simply 'Highest' in the QUINTILE columns because they all had different values for it and this fits better into with the other labels that are also more simple, such as 'Lowest'. 

```{r Reattach the geometry to merged_data_df}
# Step 5: Reattach the geometry to merged_data_df
# Since merged_data_df is no longer an sf object after the join, convert it back
# Prepare a geometry column from pse_data_2023 matching Census_Tra in merged_data_df
geometry_col <- pse_data_2023 %>% 
  select(Census_Tra, geometry) %>% 
  distinct(Census_Tra, .keep_all = TRUE)

# Join this geometry data back to the merged dataframe
GIS_EE_2023 <- merged_data_df %>%
  left_join(geometry_col, by = "Census_Tra") %>%
  st_as_sf(crs = st_crs(pse_data_2023))

# View the final sf object
head(GIS_EE_2023)
```


```{r GIS Equity Data}

# View the Racial and Social Equity data
head(equity_data)

```




```{r GIS Energy}

# View the PSE (Puget Sound Energy) Usage
head(pse_data)

```



